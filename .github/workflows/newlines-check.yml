name: Check LF line endings

on: [push, pull_request]

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

env:
  # Comma-separated list of directories to scan (recursive)
  TARGET_DIRS: "src,tests"
  # Comma-separated subdirectory names to exclude anywhere under TARGET_DIRS
  EXCLUDE_DIRS: "third_party,vendor,external,submodules"
  # Set to "true" to fail the job when CRLF is found
  FAIL_ON_CRLF: "true"

jobs:
  check-lf:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          submodules: false
          fetch-depth: 1

      - name: Scan for CRLF (expects LF)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p report

          IFS=',' read -ra TARGETS  <<< "${TARGET_DIRS:-src,tests}"
          IFS=',' read -ra EXCLUDES <<< "${EXCLUDE_DIRS:-third_party,vendor,external,submodules}"

          # Exclusion regex: (^|/)(dir1|dir2)(/|$)
          if ((${#EXCLUDES[@]})); then
            EX_RE="(^|/)($(printf '%s|' "${EXCLUDES[@]}" | sed 's/|$//'))(/|$)"
          else
            EX_RE="^$a"  # match nothing
          fi

          # Collect tracked files (NUL-safe)
          FILES=()
          for dir in "${TARGETS[@]}"; do
            [[ -d "$dir" ]] || continue
            while IFS= read -r -d '' f; do
              FILES+=("$f")
            done < <(git ls-files -z \
              "${dir}/**/*.cpp" "${dir}/**/*.hpp" "${dir}/**/*.h" \
              "${dir}/**/*.cc"  "${dir}/**/*.cxx" "${dir}/**/*.hh" "${dir}/**/*.hxx" \
              "${dir}/**/*.r" "${dir}/**/*.R" \
              "${dir}/**/*.md" "${dir}/**/*.rmd" "${dir}/**/*.Rmd" \
              "${dir}/**/*.qmd" \
              "${dir}/**/CMakeLists.txt" "${dir}/**/*.cmake" \
            )
          done

          # Filter out excluded dirs anywhere in path
          FILTERED=()
          for f in "${FILES[@]}"; do
            if ! [[ "$f" =~ $EX_RE ]]; then
              FILTERED+=("$f")
            fi
          done

          echo "Checked file count: ${#FILTERED[@]}"

          crlf_offenders=()

          for f in "${FILTERED[@]}"; do
            # If the file contains a carriage return byte, treat as CRLF/mixed
            if grep -Iq $'\r' -- "$f"; then
              crlf_offenders+=("$f")
            fi
          done

          summary_file="$GITHUB_STEP_SUMMARY"
          if ((${#crlf_offenders[@]})); then
            printf "%s\n" "${crlf_offenders[@]}" > report/crlf_files.txt

            for f in "${crlf_offenders[@]}"; do
              echo "::warning file=${f}::File has CRLF line endings; expected LF"
            done

            {
              echo "## Files with CRLF line endings"
              echo
              for f in "${crlf_offenders[@]}"; do
                echo "- \`${f}\`"
              done
              echo
            } >> "$summary_file"

            if [[ "${FAIL_ON_CRLF:-false}" == "true" ]]; then
              exit 1
            fi
          else
            echo "✅ All checked files use LF."
            echo "✅ All checked files use LF." >> "$summary_file"
          fi

      - name: Upload CRLF report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: crlf-report
          path: report/
          if-no-files-found: ignore
