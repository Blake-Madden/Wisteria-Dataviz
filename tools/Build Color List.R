library(rvest)
library(tidyverse)
library(magrittr)
library(stringi)
library(stringr)
library(janitor)
library(lubridate)

# Add any colors that you want to Colors.txt (the name should be camel-cased
# and be sure to add a hex-encoded value next to it [tab between the color name
# and hex value].)
#
# After running this, the files reportbuildercolors.cpp, colors.h, and colors.cpp
# will be rebuilt from the list of colors in Colors.txt.

dataFolder <- dirname(rstudioapi::getSourceEditorContext()$path)

# colors from various runs and manual additions
previousColorData <- read_delim(str_glue("{dataFolder}/Colors.txt"), 
                          delim = "\t", escape_double = FALSE, 
                          trim_ws = TRUE, lazy = FALSE) %>%
  mutate("Hex"=stringi::stri_trans_toupper(`Hex`))

# uncomment this to re-read content from colorhexa.
# Not recommended though, as the current list removed a few colors that seemed redundant.
#colorData <- html_table(read_html("https://www.colorhexa.com/color-names"))[[1]] %>%
# dplyr::select(c("Color name", "Hex")) %>%
#  mutate("Color name"=stringi::stri_trans_general(`Color name`, 'Latin-ASCII')) %>%
#  mutate("Color name"=stringi::stri_trans_totitle(`Color name`)) %>%
#  mutate("Color name"=stringr::str_remove_all(`Color name`, "([/]Web| |[-]|'s)")) %>%
#  mutate("Color name"=stringr::str_replace(`Color name`, "^Cg", "CG")) %>%
#  mutate("Color name"=stringr::str_replace(`Color name`, "^Ua", "UA")) %>%
#  mutate("Color name"=stringr::str_replace(`Color name`, "^Ucla", "UCLA")) %>%
#  mutate("Color name"=stringr::str_replace(`Color name`, "^Ufo", "UFO")) %>%
#  mutate("Color name"=stringr::str_replace(`Color name`, "^Up", "UP")) %>%
#  mutate("Color name"=stringr::str_replace(`Color name`, "^Usc", "USC")) %>%
#  mutate("Color name"=stringr::str_replace(`Color name`, "^Msu", "MSU")) %>%
#  mutate("Hex"=stringi::stri_trans_toupper(`Hex`))
# colorData %<>% bind_rows(previousColorData) %>%

colorData <- previousColorData %>%
  # remove duplicates
  dplyr::distinct(`Color name`, .keep_all=T)

colorData %<>%
  arrange(`Color name`) %>%
  mutate(FullColorName = str_glue('Wisteria::Colors::Color::{`Color name`}')) %>%
  mutate(Red=str_sub(Hex,2,3)) %>%
  mutate(Green=str_sub(Hex,4,5)) %>%
  mutate(Blue=str_sub(Hex,6,7)) %>%
  mutate("Values"=str_glue("RGBA(0x{`Red`},0x{`Green`},0x{`Blue`},0xFF), ")) %>%
  mutate("Enum"=str_glue("{`Color name`},{strrep(' ', (max(nchar(`Color name`))+1)-nchar(`Color name`))}///< \\htmlonly <div style='background-color:{`Hex`}; width:50px;'>&nbsp;</div> \\endhtmlonly"))

valuesStr = ""
rowsPos = 1
while (rowsPos <= nrow(colorData))
  {
  diff = if_else(rowsPos+10 > nrow(colorData), (nrow(colorData)-rowsPos)+1, 10)
  valuesStr = str_glue("{valuesStr}\n{strrep(' ',4)}{str_flatten(colorData$Values[rowsPos:((rowsPos+diff)-1)])}")
  rowsPos = rowsPos+10
  }
# chop off trailing comma
valuesStr %<>% str_remove(", $")

enumsStr = str_glue("// DO NOT EDIT THIS FILE!
// This is generated from an R script (tools/Build Color List.R)

/** @addtogroup Graphics
    @brief Graphing classes.
    @date 2005-[year(now())]
    @copyright Blake Madden
    @author Blake Madden
    @details This program is free software; you can redistribute it and/or modify
     it under the terms of the 3-Clause BSD License.

     SPDX-License-Identifier: BSD-3-Clause
@{*/

namespace Wisteria::Colors
    {
    /** @brief List of colors to use with ColorBrewer::GetColor().
        @details This list was adapted from <a href='https://www.colorhexa.com'>www.colorhexa.com</a>,
            <a href='https://www.canva.com'>www.canva.com</a>, and Sherman-Williams.*/
    enum class Color
        {\n[strrep(' ',8)]",
  str_flatten(colorData$Enum, "\n[strrep(' ',8)]"),
  "\n[strrep(' ',8)]/// @private\n[strrep(' ',8)]COLOR_COUNT\n[strrep(' ',8)]};\n[strrep(' ',4)]}\n",
  .open='[', .close=']')

# update known color list for next time
write_tsv(colorData %>% dplyr::select(c("Color name", "Hex")), str_glue("{dataFolder}/Colors.txt"))

# colors enum
write_file(str_glue("{enumsStr}"), str_glue("{dataFolder}/../src/base/colors.h"))

# this is where the content for the ColorBrewer class will go
write_file(str_glue('// DO NOT EDIT THIS FILE!
// This is generated from an R script (tools/Build Color List.R)

///////////////////////////////////////////////////////////////////////////////
// Name:        colors.cpp
// Author:      Blake Madden
// Copyright:   (c) 2005-[year(now())] Blake Madden
// Licence:     3-Clause BSD licence
// SPDX-License-Identifier: BSD-3-Clause
///////////////////////////////////////////////////////////////////////////////

#include "colorbrewer.h"

using namespace Wisteria::Colors;

const std::vector<wxUint32> ColorBrewer::m_colors =
    {[valuesStr]
    };', .open='[', .close=']'),
    str_glue('{dataFolder}/../src/base/colors.cpp'))

# the map in file ReportBuilder
reportMap <- str_flatten(str_glue('[strrep(" ",4)]{ L"[str_to_lower(colorData$`Color name`)]", [colorData$FullColorName] },\r\n',
                                  .open='[', .close=']')) %>%
  str_trim(side="right") %>% str_remove(",$")
write_file(str_glue('// DO NOT EDIT THIS FILE!
// This is generated from an R script (tools/Build Color List.R)

///////////////////////////////////////////////////////////////////////////////
// Name:        reportbuildercolors.cpp
// Author:      Blake Madden
// Copyright:   (c) 2005-[year(now())] Blake Madden
// Licence:     3-Clause BSD licence
// SPDX-License-Identifier: BSD-3-Clause
///////////////////////////////////////////////////////////////////////////////

#include "reportbuilder.h"

using namespace Wisteria::Colors;

std::map<std::wstring_view, Wisteria::Colors::Color> Wisteria::ReportBuilder::m_colorMap =
    {\n[reportMap]
    };', .open='[', .close=']'),
                    str_glue("{dataFolder}/../src/base/reportbuildercolors.cpp"))